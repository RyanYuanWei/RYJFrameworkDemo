
1.愿景：
Controller是View和Model之间的中介，这样他们就解耦了。最小的可重用单元是Controller，这对我们来说是个好消息，因为我们必须有一个来放那些不适合放入Model的复杂业务逻辑的地方。

---------------------------------------------------------------------------------------------------

2.实际情况：
Cocoa MVC鼓励人们编写大规模的视图控制器，而且由于它们涉及View的生命周期，所以很难说它们（View和Controller）是分离的。
虽然你仍有能力将一些业务逻辑和数据转换成Model，但你没办法将View从Controller中分离。在大多数时候所有View的责任是把事件传递给Controller。
ViewController最终演变成一个其他人的delegate和data source，通常负责分派和取消网络请求

View和Controller之间的交互在单元测试中是不可测试的

View + CollectionView + Cell 共同构成View层

---------------------------------------------------------------------------------------------------

3.MVC 自身的不足：
MVC 是一个用来组织代码的权威范式，也是构建 iOS App 的标准模式。Apple 甚至是这么说的。在 MVC 下，所有的对象被归类为一个 model，一个 view，或一个 controller。Model 持有数据，View 显示与用户交互的界面，而 View Controller 调解 Model 和 View 之间的交互。然而，随着模块的迭代我们越来越发现 MVC 自身存在着很多不足。

1）MVC 在现实应用中的不足：
在 MVC 模式中 view 将用户交互通知给控制器。view 的控制器通过更新 Model 来反应状态的改变。Model（通常使用 Key-Value-Observation）通知控制器来更新他们负责的 view。大多数 iOS 应用程序的代码使用这种方式来组织。

2）愈发笨重的 Controller：
在传统的 app 中模型数据一般都很简单，不涉及到复杂的业务数据逻辑处理，客户端开发受限于它自身运行的的平台终端，这一点注定使移动端不像 PC 前端那样能够处理大量的复杂的业务场景。然而随着移动平台的各种深入，我们不得不考虑这个问题。传统的 Model 数据大多来源于网络数据，拿到网络数据后客户端要做的事情就是将数据直接按照顺序画在界面上。随着业务的越来越来的深入，我们依赖的 service 服务可能在大多时间无法第一时间满足客户端需要的数据需求，移动端愈发的要自行处理一部分逻辑计算操作。这个时间一惯的做法是在控制器中处理，最终导致了控制器成了垃圾箱，越来越不可维护。

控制器 Controller 是 app 的 “胶水代码”，协调模型和视图之间的所有交互。控制器负责管理他们所拥有的视图的视图层次结构，还要响应视图的 loading、appearing、disappearing 等等，同时往往也会充满我们不愿暴露的 Model 的模型逻辑以及不愿暴露给视图的业务逻辑。这引出了第一个关于 MVC 的问题...

视图 view 通常是 UIKit 控件（component，这里根据习惯译为控件）或者编码定义的 UIKit 控件的集合。进入 .xib 或者 Storyboard 会发现一个 app、Button、Label 都是由这些可视化的和可交互的控件组成。View 不应该直接引用 Model，并且仅仅通过 IBAction 事件引用 controller。业务逻辑很明显不归入 view，视图本身没有任何业务。

厚重的 View Controller 由于大量的代码被放进 viewcontroller，导致他们变的相当臃肿。在 iOS 中有的 view controller 里绵延成千上万行代码的事并不是前所未见的。这些超重 app 的突出情况包括：厚重的 View Controller 很难维护（由于其庞大的规模）；包含几十个属性，使他们的状态难以管理；遵循许多协议（protocol），导致协议的响应代码和 controller 的逻辑代码混淆在一起。

厚重的 view controller 很难测试，不管是手动测试或是使用单元测试，因为有太多可能的状态。将代码分解成更小的多个模块通常是件好事。

3）太过于轻量级的 Model：

早期的 Model 层，其实就是如果数据有几个属性，就定义几个属性，ARC 普及以后我们在 Model 层的实现文件中基本上看不到代码（无需再手动管理释放变量，Model 既没有复杂的业务处理，也没有对象的构造，基本上 .m 文件中的代码普遍是空的）；同时与控制器的代码越来厚重形成强烈的反差，这一度让人不禁对现有的开发设计构思有所怀疑。

4）遗失的网络逻辑：

苹果使用的 MVC 的定义是这么说的：所有的对象都可以被归类为一个 Model，一个 view，或是一个控制器。就这些，那么把网络代码放哪里？和一个 API 通信的代码应该放在哪儿？

你可能试着把它放在 Model 对象里，但是也会很棘手，因为网络调用应该使用异步，这样如果一个网络请求比持有它的 Model 生命周期更长，事情将变的复杂。显然也不应该把网络代码放在 view 里，因此只剩下控制器了。这同样是个坏主意，因为这加剧了厚重控制器的问题。那么应该放在那里呢？显然 MVC 的 3 大组件根本没有适合放这些代码的地方。

5）较差的可测试性

MVC 的另一个大问题是，它不鼓励开发人员编写单元测试。由于控制器混合了视图处理逻辑和业务逻辑，分离这些成分的单元测试成了一个艰巨的任务。大多数人选择忽略这个任务，那就是不做任何测试。

上文提到了控制器可以管理视图的层次结构；控制器有一个 “view” 属性，并且可以通过 IBOutlet 访问视图的任何子视图。当有很多 outlet 时这样做不易于扩展，在某种意义上，最好不要使用子视图控制器（child view controller）来帮助管理子视图。在这里有多个模糊的标准，似乎没有人能完全达成一致。貌似无论如何，view 和对应的 controller 都紧紧的耦合在一起，总之，还是会把它们当成一个组件来对待。Apple 提供的这个组件一度以来在某种程度误导了大多初学者，初学者将所有的视图全部拖到 xib 中，连接大量的 IBoutLet 输出口属性，都是一些列问题。

---------------------------------------------------------------------------------------------------

4.总结：
职责拆分 — View和Model实现了分离，但是View与Controller仍是紧耦合。

可测性 — 由于模式的原因，你只能测试你的Model。

易用性 — 相比于其他模式代码量最少。此外，每个人都熟悉它，即使经验不太丰富的开发人员也能够维护它。

如果你不愿意在项目的架构上投入太多的时间，那么Cocoa MVC 就是你应该选择的模式。而且你会发现用其他维护成本较高的模式开发小的应用是一个致命的错误。

Cocoa MVC是开发速度最快的架构模式。

---------------------------------------------------------------------------------------------------

PS：MVC中网络层应该放在C层还是M层的思考
1.MVC中网络层应该放哪儿在架构中是缺失的一环，所以一些人喜欢放M层一些人喜欢放C层
2.个人觉得应该放C层，因为网络请求的生命周期和控制器的生命周期基本上是同步的，但是与model不一定同步。只要页面存在就有可能获取数据，页面销毁后通常不再获取数据。如果把获取数据的逻辑放在model层，每次需要获取数据时需要先创建一个model且返回数据时model对象不一定还存在。
3.如果model去获取列表数据，返回结果model需要使用一个数组对象去存储，同时需要创建针对单个对象的模型类，加深了model的复杂度。反之由Controller去获取列表数据，列表数据源存在与C层，model只作为单个对象的模型类
4.一个Model应该可以同时对应多个Controller+View，但是网络请求往往与Controller强相关，若将网络请求放在Model不利于其复用
5.即使获取数据放在C层，最好对网络请求进行封装，Controller仅保留简单的请求发起及回调
6.MVC将网络请求放入C层依然不是完美的解决方案，它会造成原本简单的model更加简单，臃肿的Controller更加臃肿。如果存在多个网络请求的情况，放在model层分工会更加明确

